---
layout: default
title: 용어 정리
parent: Web Publishing
nav_order: 92
---

# 용어 정리
{: .no_toc }

 ## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc .contents-list}


----
### 네이티브앱

> 어플리케이션, 앱 스토어에서 구매 설치<br>
{:.list}

### 모바일웹

> 모바일 웹사이트 <br>
모바일 기기화면에 최적화 ui/ux를 염두 <br>
{:.list}

### 웹앱
> 모바일웹 + 네이티브앱을 결합 <br>
모바일웹보다 실행속도 빠름 <br>
url를 치고 들어감 <br>
마켓 등록 판매하지 않는다 <br>
모바일웹보다 더 모바일에 최적화  <br>
AJAX 통신과 HTML5로컬저장소를 이용하여 네이티브 앱과 유사한 실행환경제공  <br>
{:.list}

### 하이브리드앱
> 웹앱을 네이티브 앱으로 포장한 것 <br>
다음앱/네이버앱/구글앱등등 <br>
마켓등록 판매 <br>
{:.list}

### 반응형웹
> N스크린 시대에 맞추어 화면이 자동으로 리사이징
{:.list}

### 적응형웹
> 스크린 사이즈에 미디어 쿼리와 스크립트를 활용하여 레이아웃 변형, 화면 구성 <br>
몇개의 스크린 사이즈를 기준으로 화면 구성 <br>
반응형웹보다 정교함이 덜함 <br>
{:.list}


### 반응형 웹디자인이란
> 다양한 디비이스에 대응하여 최소한의 변화로 내용탐색을 쉽게하여 사이트를 최적의 형태로 제공하는 기술
{:.list}

---

### compile(컴파일)
> 사용자가 작성한 코드를 컴퓨터가 이해할 수 있는 언어로 번역하는 일
{:.list}

### build(빌드)
컴파일된 코드를 실제 실행할 수 있는 상태로 만드는 일

### deploy(배포)
빌드가 완성된 실행 가능한 파일을 사용자가 접근할 수 있는 환경에 배치시키는 일

### transpile(트랜스파일)
> 한언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환하는 것
[ex] es6 코드 -> es5 코드로 변환
{:.list}


---

### CSS Houdini
> Houdini 프로젝트는 Mozilla, Apple, Opera, Microsoft, HP, Intel 그리고 Google의 엔지니어들로 구성되어 CSS 엔진의 일부분에 웹 개발자들이 접근할 수 있도록 협업하고 있습니다. 이 프로젝트는 공식 W3C 표준으로 채택되기 위한 표준 초안들을 작성하고 있습니다. 프로젝트의 구성원들은 표준안에 대한 몇 가지 높은 수준의 목표를 세워 표준 초안을 작성하였으며 이를 기반으로 하위 수준 사양의 표준 문서들이 개발되었습니다. 결국, “Houdini”라하면 이 표준 문서들의 내용을 의미합니다. 
{:.list}


### 보임 필터 선택자 (Visibility Filter)
Visibility Filter 선택자는 화면에 보이거나 보이지 않는 노드들을 찾아 준다.

- CSS display 속성값이 none 일 때
- 요소 중에 type=”hidden”일 때
- 요소의 width와 height가 0일 때
- 부모 요소가 보이지 않거나 숨겨져 있을 때

`visibility:hidden`{:.property}, `opacity:0`{:.property} <br>
노드들의 위치에서 제거되지 않고 일정공간을 차지 하고 있음. <br>
따라서 이 속성들은 `:hidden`선택자에게 선택되지 않는다.

---

### 전문가 사용성 리뷰
사용자의 작업이 막힐만한 법한 부분, 사용자가 헷갈릴수 있는 부분에 대해 기록

### 사용성평가
다른사람이 사용하는 모습을 관찰하며 그들이 어디에서 막히는 지, 어디에서 혼란스러워 하는지 기록

### USP 전략
오직 해당제품만 가지고 있는 유니크한 장점을 판매 포인트로 부각 시켜 마케팅에 활용하는 것을 뜻함

---

### KickOff Meeting

##### KickOff Meeting?
웹 개발의 첫 단추가 되는 중요한 단계
프로젝트 팀과 클라인트와 주축이 되는 첫 미팅
프로젝트의 대한 결정사항이 이루어지는 미팅

##### KickOff Meeting시 확인할 사항
정의 되는 내용에 대해서 서로 이해 할수 있는 단계가 되어야 한다.
미팅 시 모를 수 있는 전문 용어는 피하고 풀어서 이야기를 해야 한다.
주요 결정 사항은 미팅에 참석한 모든 사람이 이해 할 수 있어야 한다.
미팅 참석자 한테는 동일한 미팅지를 제공해야 한다.
프로젝트 팀과 클라이언트 간의 커뮤니케이션 라인을 정확히 정의를 해야 한다.
좋은 시작은 좋은 결과를 가져 온다.


---

### O2O(online to Offline)플랫폼

스마트 폰 보급이 폭발적으로 늘어나고 근거리선 통신(NFC)과 저전력 블루투수(BLE), 지리정보시스템(GPS)등의 기술이 발전하면서 사용자들의 위치를 탐지해 맞춤형 메시지를 전송하고 모바일 결제까지 한번에 할수 있는 서비스
* 모바일 앱으로 오프라인 상점에서 미리 식사나 커피를 주문 결제 할 수 있는 서비스

---

### 디자인 도구 

##### 다이어 그램
복잡한 인터랙션 흐름를 쉽게 파악할 수 있습니다. 개발에 걸리는 시간을 예측하거나 디자인을 설명할 때 많은 도움이 됩니다.

##### 스케치
빨리 그려보고 버릴 수 있는 데에 적합합니다.

##### 와이어프레임
와이어프레임은 디자인을 세밀하게 파악할 수 있는 도구입니다. 하나의 와이어프레임에는 모든 상태에 대한 화면이 포함됩니다.

##### 인터랙티브 프로토타입
제품 전체를 어렵게 구현하는 대신 실제와 아주 가까운 제품을 테스트함으로써 시간과 비용을 절약할 수 있을 때 적합한 도구입니다.

---


### Lean UX
<div class="code-example" markdown="1">
**디자인 씽킹(디자인)**
사람들의 행동과 니즈에 대한 관찰을 기반으로 분석적 사고와 직관적 사고가 융합된 문제 해결 접근 방식.
관찰, 브레인스토밍, 프로토타입등 다양한 디자인 방법론을 활용

**애자일 개발 방법론(개발)**
변화에 빠르고 유연하게 대응하기 위해 주기적인 이터레이션(반복)과 긴민할 협업을 통해 점진적으로 구현해나가는 소프트웨어 개발 방법

**린 스타트업(기획)**
위험을 최소화하고 사용자에게 가치있는 제품은 만들기 위해 제작 - 측정 - 학습이라는 순환 피드백을 활용
</div>

> Lean UX = 위의 세 가지의 교집합에 위치한 UX방식.

Lean UX도 Agile UX와 마찬가지로 '협업'을 중요시하는 개발법.
빠른 프로토타이핑과 고객 피드백을 기반으로 제품 경험을 디자인하고 제품의 진정한 가치를 이끌어내고자 하는 기법.

Lean UX의 순서
- 핵심가치를 정의
- 정한 핵심자치에 기반한 가설을 '빨리' 만듬
- 가설을 '빨리' 검증
- 핵심지표를 보며 계속해서 조정해가는 것

---
### Agile UX 
기존의 개발 프로레스(waterfall 방식) '기획 - 디자인 - 개발 - 검증 - 출시'의 프로레스의 긴 이터레이셔 구조는 검증(사용자 피드백)을 반영하기 힘들다.
이 구조를 개선 검증 단계를 앞당기고자 UI 리뷰, 페이퍼프로토타이핑등의 방법을 이용하는 시도.
즉, 빠르게 출시한 뒤 점진적으로 개선해 나가는 것을 주요하게 생각하는 방법론.

---
### 이터레이션(iteration)
- 이터레이션이란 '반복'이라는 단어로 프로젝트를 '이터레이션'이라는 단위로 나누어 개발을 함을 뜻한다.
- 이터레이션 회의에는 모든 프로젝트 관계자들이 참여하게되고 그때 나온 수정사항은 다음 이터레이션에 반영된다.
- 이터레이션은 눈으로 볼 수 있는 결과물이 나와야하며 피드백을 받을 수 있어야 한다.

---

### 이벤트 버블링 
하위 엘리먼트에서 상위 엘리먼트로 이벤트가 전파되는 특성

---

### 스코프
어떤 변수의 대한 유효범위

---

### Repository
코드가 존재하는 장소(주소)를 지정.
npm docs 명령을 사용하여 패키지 저장소를 쉽게 찾을 수 있다.

---


### 이터러블
- 순회 가능한 자료구조
- 이터레이터를 리턴하는 [Symbol.iterator]() 를 가진 값
- Array, String, Map, Set, DOM data structures



### 이터레이터
- 순회 가능한 객체
- { value, done } 객체를 리턴하는 next() 를 가진 값
- 이터러블 프로토콜을 지킨 이터러블은 Symbol.iterator 메소드를 가지고 있다.
- 해당 이터러블이 Symbol.iterator 메소드를 호출하면 이터레이터를 반환할 수 있다.
- 이터레이터는 이터러블의 각 요소를 순회하기 위해 next 메소드를 갖는다.
- next는 각 단계의 값인 value와 모든 단계를 끝냈는지를 알려주는 done을 반환한다.


----

### Thread(쓰레드)
쓰레드는 프로세스 내에서 실제로 작업을 수행하는 주체를 의미한다.
- single thread(싱글쓰레드) - 첫번째 작업을 시작하고 끝낸 후 다음 두번째 작업을 시작한다.(node.js)
- Multi Thread(멀티쓰레드) - 두개의 쓰레드가 두개의 작업을 짧은시간동안 번갈아가며 수행하기 때문에 두개의 작업이 동시에 처리되는것으로 보인다.

----

### Cookies, Session, Token, JWT
- Cookies: 웹브라우저 단에 임시로 데이터 저장, 
    - 도메인에 제한 됨.
    - 유효기간이 있음.
    - 사용자에게 발급된 세션을 열기 위한 열쇠(Session ID)
- Session: 서버에서 가지고 있는 정보
    - Session에 대한 정보를 주로 서버의 메모리에 저장하게 되는데 사용자의 수가 늘어날 수록 메모리의 부하가 커지는 문제점
- Token: 본인 확인 수단.
    - 로그인을 할 때 id와 pw를 넣고 로그인을 하면 서버가 그것을 확인 해서 id와 pw가 맞으면 이 사용자가 유효한 사용자라는 토큰을 발행
- JWT(Json Web Token): 인증에 필요한 정보들을 암호화시킨 토큰
    - Session이나 DB없이 인증할수 있음.
    - 서버가 기억하는 이상하게 생긴 텍스트(string)
    - 토큰형식
    - 제약이 없음.
    - 강제 로그아웃이 없음.(단점: JWT는 한 번 발급되면 유효기간이 완료될 때 까지는 계속 사용이 가능합니다. 악의적인 사용자는 유효기간이 지나기 전까지 정보 탈취가 가능)
        - 해결책 : 기존의 Access Token의 유효기간을 짧게 하고 Refresh Token이라는 새로운 토큰을 발급합니다. 그렇게 되면 Access Token을 탈취당해도 상대적으로 피해를 줄일 수 있습니다. 
    - 확장성이 뛰어남.
    - 세션/쿠키는 별도의 저장소의 관리가 필요.
    - 발급한 후 검증만 하면 되기 때문에 추가 저장소가 필요 없습니다.
    - Payload 정보가 제한적, Payload는 따로 암호화되지 않기 때문에 디코딩하면 누구나 정보를 확인가능하므로 따라서 유저의 중요한 정보들은 Payload에 넣을 수 없다.
    - 세션/쿠키 방식에 비해 JWT의 길이는 길다.(인증이 필요한 요청이 많아질 수록 서버의 자원낭비가 발생)

---

### 체이닝(chaining)
새로운 인스턴스를 생성하고 바로 메서드를 연결하는 방법




---

## 참고링크
- [CSS Houdini](https://css-houdini.rocks/){:target="_blank"}
- [CSS Paint API](https://wit.nts-corp.com/2018/05/02/5214){:target="_blank"}
- [디독 : 린 UX를 실무에 적용하는 효과적인 방법]
- [Lean UX Aagile UX 소개...](https://trello.com/c/utUdqIkJ){:target="_blank"}
- [컴파일? 빌드? 배포? 개념과 차이는 무엇일까?](https://itholic.github.io/qa-compile-build-deploy/){:target="_blank"}
-  [[JS] 이터러블과 이터레이터](https://n-log.tistory.com/21){:target="_blank"} 
-  [싱글쓰레드와 멀티쓰레드](https://blog.naver.com/drogba02/221632424858){:target="_blank"} 
